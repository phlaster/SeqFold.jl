var documenterSearchIndex = {"docs":
[{"location":"juliacall/#Calling-from-Python-scripts","page":"For Python users","title":"Calling from Python scripts","text":"","category":"section"},{"location":"juliacall/","page":"For Python users","title":"For Python users","text":"SeqFold can be called from Python scripts via juliacall package:","category":"page"},{"location":"juliacall/","page":"For Python users","title":"For Python users","text":"Install juliacall package through you favourite package manager (pip, Conda, uv):","category":"page"},{"location":"juliacall/","page":"For Python users","title":"For Python users","text":"$ pip install juliacall","category":"page"},{"location":"juliacall/","page":"For Python users","title":"For Python users","text":"In Python REPL:","category":"page"},{"location":"juliacall/","page":"For Python users","title":"For Python users","text":"Python 3.13.7 | packaged by conda-forge | (main, Sep  3 2025, 14:30:35) [GCC 14.3.0] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> from juliacall import Main as jl # this will download Julia binaries\n>>> jl.seval(\"\"\"using Pkg; Pkg.add(url=\"https://github.com/phlaster/SeqFold.jl\")\"\"\")\n>>> jl.seval(\"using SeqFold\") # this exports tm, fold, dg, ...\n>>> jl.fold(\"ACACGCAGCGGGTGTGGCTGTGGTGC\")\nJulia:\n4-element Vector{SeqFold.Structure}:\n    1   13   -1.9  STACK_DE:AC/TG \n    2   12   -2.3  STACK:CAC/GGG  \n    4   10   -2.2  STACK:CG/GC    \n    5    9    3.5  HAIRPIN:GC/CG  \n>>> jl.dg(\"ACACGCAGCGGGTGTGGCTGTGGTGC\")\n-2.9","category":"page"},{"location":"juliacall/","page":"For Python users","title":"For Python users","text":"note: Note\nRemember, that calling a function in Julia for the first time takes more time due to JIT compiliation.","category":"page"},{"location":"tm/#Melting-Temperature-Calculation","page":"Melting Temperature","title":"Melting Temperature Calculation","text":"","category":"section"},{"location":"tm/","page":"Melting Temperature","title":"Melting Temperature","text":"SeqFold.jl provides functions for calculating DNA melting temperatures using nearest-neighbor thermodynamics.","category":"page"},{"location":"tm/#Basic-Usage","page":"Melting Temperature","title":"Basic Usage","text":"","category":"section"},{"location":"tm/#SeqFold.tm","page":"Melting Temperature","title":"SeqFold.tm","text":"tm(seq1, seq2; conditions=:pcr, kwargs...) -> Float64\ntm(seq; conditions=:pcr, kwargs...)  -> Float64\n\nCalculate melting temperature (Tm °C) for DNA duplex formation using nearest-neighbor thermodynamics.\n\nArguments\n\nseq1::AbstractString: DNA sequence;\nseq2::AbstractString: Another DNA sequence, must be the same length as seq1;\nseq::AbstractString: Single DNA sequence to be matched with its exact complement;\nconditions: Buffer conditions specification (see below);\nkwargs...: Additional parameters to override preset conditions in place.\n\nConditions Specification\n\nThe conditions parameter can be:\n\n:pcr (default) or :std: Use preset conditions;\nMeltingConditions object: Custom conditions (for more info see: MeltingConditions);\nNTuple{7, Float64}: (seq1_conc, seq2_conc, Na, K, Tris, Mg, dNTPs);\nNamedTuple with condition fields.\n\nExamples\n\njulia> tm(\"GGGGGG\")\n15.5\n\njulia> tm(\"GGGGGG\", conditions=:pcr)\n15.5\n\njulia> tm(\"GGGGGG\", Mg=10)\n23.0\n\njulia> tm(\"GGGGGG\", conditions=:std)\n2.6\n\njulia> tm(\"GGGGGG\", conditions=:std, Na=100)\n5.1\n\njulia> tm(\"GGGGGG\", conditions=MeltingConditions(150, 150, 20, 0, 0, 10, 0))\n16.8\n\njulia> tm(\"ACCCCC\", \"GGGGGG\")\n6.2\n\nImplementation\n\nThe calculation uses nearest-neighbor thermodynamic parameters from related literature (follow links below to see sources), accounting for initialization terms, nearest-neighbor pairs, and terminal mismatches when present.\n\nSee also\n\nMeltingConditions\n\n\n\n\n\n","category":"function"},{"location":"tm/#SeqFold.tm_cache","page":"Melting Temperature","title":"SeqFold.tm_cache","text":"tm_cache(seq1, seq2; conditions=:pcr, kwargs...) -> Matrix{Float64}\ntm_cache(seq; conditions=:pcr, kwargs...) -> Matrix{Float64}\n\nCompute a matrix of melting temperatures for all possible subsequences of a DNA sequence pair.\n\nArguments\n\nseq1::AbstractString: DNA sequence;\nseq2::AbstractString: Another DNA sequence, must be the same length as seq1;\nseq::AbstractString: Single DNA sequence to be matched with its exact complement;\nconditions: Buffer conditions specification (see tm docstrings);\nkwargs...: Additional parameters to override preset conditions in place.\n\nReturns\n\nA Matrix{Float64} where element (i, j) contains the melting temperature (in °C) of the subsequence from position i to position j, inclusive. Elements where j < i contain Inf as they represent invalid ranges, and single-nucleotide subsequences also have Inf as they don't have meaningful Tm values.\n\nExamples\n\njulia> SeqFold.tm_cache(\"ATCC\")\n4×4 Matrix{Float64}:\n Inf  -212.6   -95.3   -48.6\n Inf    Inf   -161.6   -82.7\n Inf    Inf     Inf   -135.5\n Inf    Inf     Inf     Inf\n\njulia> SeqFold.tm_cache(\"AAGC\", \"TTCG\")\n4×4 Matrix{Float64}:\n Inf  -204.8   -94.6   -40.3\n Inf    Inf   -166.7   -72.9\n Inf    Inf     Inf   -116.7\n Inf    Inf     Inf     Inf\n\njulia> SeqFold.tm_cache(\"AAGC\", \"TTCG\"; conditions=:std)\n4×4 Matrix{Float64}:\n Inf  -213.1  -109.3   -55.6\n Inf    Inf   -177.9   -88.1\n Inf    Inf     Inf   -129.8\n Inf    Inf     Inf     Inf\n\nImplementation\n\nThe function uses dynamic programming to build a cache of Tm values for all subsequences. The algorithm has O(n²) time and space complexity, where n is the sequence length. This approach avoids redundant calculations when multiple Tm values for different subsequences are needed.\n\nSee also\n\ntm, SeqFold.gc_cache, SeqFold.dg_cache\n\n\n\n\n\n","category":"function"},{"location":"tm/#SeqFold.MeltingConditions","page":"Melting Temperature","title":"SeqFold.MeltingConditions","text":"MeltingConditions(seq1_conc, seq2_conc, Na, K, Tris, Mg, dNTPs)\n\nRepresents buffer conditions for melting temperature calculation.\n\nFields and Units\n\nseq1_conc, seq2_conc: Sequence concentrations in nM (nanomolar)\nNa, K, Tris, Mg, dNTPs: Buffer component concentrations in mM (millimolar)\n\nExamples\n\njulia> MeltingConditions(:pcr)\nMeltingConditions (PCR preset)\n  • NEB PCR buffer conditions for Taq DNA Polymerase\n  • seq1 concentration: 250.0 nM (typical primer concentration)\n  • seq2 concentration: 0.0 nM (asymmetric PCR)\n  • Mg²⁺: 1.5 mM (optimal for Taq DNA Polymerase per NEB guidelines)\n  • K⁺: 50.0 mM\n  • Tris: 2.0 mM\n  • dNTPs: 0.2 mM\n\njulia> MeltingConditions(:std)\nMeltingConditions (standard preset)\n  • Standard hybridization buffer\n  • seq1 concentration: 25.0 nM\n  • seq2 concentration: 25.0 nM\n  • Na⁺: 50.0 mM\n\njulia> MeltingConditions(seq1_conc=10,seq2_conc=0,Na=0,K=0,Tris=10,Mg=0,dNTPs=0)\nMeltingConditions (custom)\n  • seq1 concentration: 10.0 nM\n  • seq2 concentration: 0.0 nM\n  • Tris: 10.0 mM\n\njulia> MeltingConditions(10,0,0,0,0,5,0)\nMeltingConditions (custom)\n  • seq1 concentration: 10.0 nM\n  • seq2 concentration: 0.0 nM\n  • Mg²⁺: 5.0 mM (higher than NEB's recommended 1.5-2.0 mM range)\n\njulia> MeltingConditions(seq1_conc=0,seq2_conc=0,Na=5,K=0,Tris=0,Mg=0,dNTPs=0)\nERROR: ArgumentError: DNA concentration is too low!\n[...]\n\njulia> MeltingConditions(seq1_conc=10,seq2_conc=10,Na=0,K=0,Tris=0,Mg=0,dNTPs=0)\nERROR: ArgumentError: No cations for salt correction (Mg=0, Na=0, K=0, Tris=0)\n[...]\n\nSee also\n\ntm, SeqFold.tm_cache\n\n\n\n\n\n","category":"type"},{"location":"tm/#SeqFold.gc_cache","page":"Melting Temperature","title":"SeqFold.gc_cache","text":"gc_cache(seq) -> Matrix{Float64}\n\nCompute a matrix of GC scores for all possible subsequences of a DNA sequence.\n\nThe resulting matrix has element [i, j] representing the GC score of the DNA subsequence from position i to position j. This cache enables efficient GC ratio calculations for various subsequences without redundant computations.\n\nArguments\n\nseq::AbstractString: The DNA sequence to analyze\n\nReturns\n\nA Matrix{Float64} where element [i, j] contains the GC ratio of the subsequence from position i to j. Elements where j < i contain Inf as they represent invalid ranges.\n\nExamples\n\njulia> SeqFold.gc_cache(\"GGAA\")\n4×4 Matrix{Float64}:\n  1.0   1.0   0.666667  0.5\n Inf    1.0   0.5       0.333333\n Inf   Inf    0.0       0.0\n Inf   Inf   Inf        0.0\n\njulia> SeqFold.gc_cache(\"GAAA\")\n4×4 Matrix{Float64}:\n  1.0   0.5   0.333333  0.25\n Inf    0.0   0.0       0.0\n Inf   Inf    0.0       0.0\n Inf   Inf   Inf        0.0\n\njulia> SeqFold.gc_cache(\"ATA\")\n3×3 Matrix{Float64}:\n  0.0   0.0  0.0\n Inf    0.0  0.0\n Inf   Inf   0.0\n\njulia> SeqFold.gc_cache(\"GGTT\") == SeqFold.gc_cache(\"CCAA\")\ntrue\n\nSee also\n\nSeqFold.tm_cache, tm, SeqFold.dg_cache\n\n\n\n\n\n","category":"function"},{"location":"tm/#Implementation-Details","page":"Melting Temperature","title":"Implementation Details","text":"","category":"section"},{"location":"tm/","page":"Melting Temperature","title":"Melting Temperature","text":"The calculation uses nearest-neighbor thermodynamic parameters from related literature, accounting for initialization terms, nearest-neighbor pairs, and terminal mismatches when present.","category":"page"},{"location":"tm/","page":"Melting Temperature","title":"Melting Temperature","text":"note: Note\nFor implementation details, see the source code documentation of the internal constants  DNA_NN, DNA_INTERNAL_MM, and DNA_TERMINAL_MM.","category":"page"},{"location":"fold/#Sequence-Folding","page":"Sequence Folding","title":"Sequence Folding","text":"","category":"section"},{"location":"fold/","page":"Sequence Folding","title":"Sequence Folding","text":"SeqFold.jl implements the Zuker and Stiegler (1981) dynamic programming algorithm for predicting nucleic acid secondary structures.","category":"page"},{"location":"fold/#SeqFold.fold","page":"Sequence Folding","title":"SeqFold.fold","text":"fold(seq; temp = 37.0) -> Vector{Structure}\n\nPredict the minimum free energy secondary structure of a nucleic acid sequence using a dynamic programming algorithm based on the Zuker and Stiegler (1981) approach. https://www.ncbi.nlm.nih.gov/pmc/articles/PMC326673/pdf/nar00394-0137.pdf\n\nImplements the core of the nucleic acid folding algorithm. It calculates the thermodynamically most stable secondary structure for a given single-stranded DNA or RNA sequence. The result is a vector of  SeqFold.Structure objects, each element representing a distinct secondary structure (e.g., hairpin loop, stacked pair, bulge, interior loop, multibranch loop) that contributes to the overall folded structure.\n\nAn optimization is applied where \"isolated\" base pairs (those not adjacent to other base pairs) are penalized with a high energy cost (1600.0 kcal/mol) to speed up computation. A base pair (i,j) is considered isolated if neither the pair (i-1, j+1) nor the pair (i+1, j-1) are complementary according to the sequence's complementarity rules. This optimization is applied regardless of sequence length.\n\nArguments\n\nseq::AbstractString: DNA/RNA sequence\ntemp::Real: The temperature (°C) at which the folding is performed (default: 37.0).\n\nExamples\n\njulia> fold(\"CCAACCGGTTGG\")\n4-element Vector{SeqFold.Structure}:\n    1   12   -1.8  STACK:CC/GG    \n    2   11   -1.5  STACK:CA/GT    \n    3   10   -1.0  STACK:AA/TT    \n    4    9    3.5  HAIRPIN:AC/TG  \n\njulia> fold(\"CCAACCGGTTGG\", temp=70)\n2-element Vector{SeqFold.Structure}:\n    5   12   -1.6  STACK_DE:CC/GG \n    6   11    3.2  HAIRPIN:CG/GT  \n\nSee also\n\ndg, dot_bracket, SeqFold.Structure\n\n\n\n\n\n","category":"function"},{"location":"fold/#SeqFold.Structure","page":"Sequence Folding","title":"SeqFold.Structure","text":"Structure(e, desc, ij)\n\nRepresents a structural element within a predicted nucleic acid secondary structure.\n\nA Structure object encapsulates the energetic contribution (e), a descriptive string (desc) detailing the type of structural element (e.g., hairpin, stack, bulge, multibranch), and the base-pairing information (ij).\n\nThis type is primarily used internally by the folding algorithm (see fold) to represent and cache the energetics of different structural motifs. It can also be used to inspect the detailed components of a folded structure.\n\nFields\n\ne::Float64: The free energy contribution (in kcal/mol) of this structural element. A value of -Inf typically signifies an uninitialized or invalid structure, while Inf often represents a null or discarded possibility during folding.\ndesc::String: A human-readable description of the structural element. Common descriptions include:\n\"HAIRPIN:<seq>\": A hairpin loop closed by specific base pairs.\n\"STACK:<bp1>/<bp2>\": A stacked base pair.\n\"BULGE:<size>\": A bulge loop of a specific size.\n\"INTERIOR_LOOP:<size1>/<size2>\": An interior loop with specified sizes on each side.\n\"BIFURCATION:<unpaired>n/<helices>h\": A multibranch loop with a certain number of unpaired nucleotides and helices.\nij::Vector{Tuple{Int, Int}}: A list of base-pair indices (i, j) involved in this structural element. For simple elements like a single hairpin or stack, this typically contains one tuple (i, j) indicating the 1-based indices of the paired nucleotides. For complex elements like multibranch loops, it can contain multiple tuples representing the various stems (helices) that constitute the junction.\n\nExamples\n\njulia> s1 = SeqFold.Structure() # Default, uninitialized\n   0    0   -Inf\n\njulia> s2 = SeqFold.Structure(-3.2, \"HAIRPIN:CG/CG\", [(2, 7)])\n   2    7   -3.2  HAIRPIN:CG/CG\n\njulia> s3 = SeqFold.Structure(5.1, \"BIFURCATION:2n/3h\", [(1, 10), (15, 20), (25, 30)])\n   1   10    5.1  BIFURCATION:2n/3h\n\njulia> Bool(s1) # Check if structure is valid (not -Inf)\nfalse\n\njulia> Bool(s2)\ntrue\n\njulia> s2 == SeqFold.Structure(-3.2, \"HAIRPIN:CG/CG\", [(2, 7)]) # Structures can be compared\ntrue\n\nSee also\n\nfold, dg, dot_bracket\n\n\n\n\n\n","category":"type"},{"location":"fold/#SeqFold.dot_bracket","page":"Sequence Folding","title":"SeqFold.dot_bracket","text":"dot_bracket(seq, structs) -> String\n\nGenerate the dot-bracket notation representation of a predicted nucleic acid secondary structure.\n\nArguments\n\nseq::AbstractString: The original nucleotide sequence that was folded.\nstructs::Vector{Structure}: A vector of Structure objects describing the folded structure, typically obtained from the fold function.\n\nExamples\n\njulia> s = \"AATTACGTTAC\";\n\njulia> dot_bracket(s, fold(s))\n\"((.....))..\"\n\njulia> seq2 = \"GGGAGGTCAGCAAACCTGAACCTGTTGAGATGTTGACGTCAGGAAACCCT\";\n\njulia> structs2 = fold(seq2)\n12-element Vector{SeqFold.Structure}:\n    3   40   -1.3  STACK:GA/CT    \n    4   39   -1.4  STACK:AGG/TGC  \n    6   37   -1.5  STACK:GT/CA    \n    7   36   -1.3  STACK:TC/AG    \n    8   35   -1.5  STACK:CA/GT    \n    9   34   -2.0  STACK:AGC/TTG  \n   11   32   -1.5  STACK:CA/GT    \n   12   31    2.8  INTERIOR_LOOP:4/2\n   16   29   -1.3  STACK:CT/GA    \n   17   28   -0.1  STACK:TGA/AGT  \n   19   26   -1.0  STACK:AA/TT    \n   20   25    3.5  HAIRPIN:AC/TG   \n\njulia> dbn = dot_bracket(seq2, structs2)\n\"..((.((((.((...((.((....)).)).)).)))).))..........\"\n\njulia> length(dbn) == length(seq2)\ntrue\n\njulia> count(==('('), dbn)  # Count base pairs\n12\n\nNotes\n\nThe function only considers the base pairs explicitly listed in the .ij field of each Structure.\nIt does not validate that the input structures are consistent or represent a physically possible configuration.\nPseudoknots (non-nested base pairs) are not handled by this simple representation and will not be correctly shown if present in the input structures.\n\nSee also\n\nfold, SeqFold.Structure\n\n\n\n\n\n","category":"function"},{"location":"fold/#SeqFold.dg","page":"Sequence Folding","title":"SeqFold.dg","text":"dg(seq; temp = 37.0) -> Float64\ndg(structures) -> Float64\n\nCompute the minimum free energy (ΔG, kcal/mol⁻¹) of a single-stranded nucleic acid sequence at a specified temperature.\n\nThe function is a thin wrapper around the more general fold routine, which generates all energetically feasible secondary structures for the sequence.   Only the sum of the free-energy contributions of the returned structures is reported, rounded to two decimal places.\n\nArguments\n\nseq::AbstractString – the nucleotide sequence to be folded;\ntemp::Real – the temperature (°C) at which to perform the folding (default: 37.0);\nstructures::Vector{Structure} – result of fold function.\n\nReturns\n\nΔG::Float64 – the total free energy of the predicted structure, rounded to two decimal places.\n\nExamples\n\njulia> seq = \"GCGCGCGCGCG\";\n\njulia> dg(seq)\n-3.0\n\njulia> dg(seq, temp=20)\n-4.9\n\njulia> structures = fold(seq);\n\njulia> dg(structures)\n-3.0\n\nSee also\n\nfold, SeqFold.dg_cache\n\n\n\n\n\n","category":"function"},{"location":"fold/#SeqFold.dg_cache","page":"Sequence Folding","title":"SeqFold.dg_cache","text":"dg_cache(seq; temp = 37.0) -> Matrix{Float64}\n\nCompute a matrix of free energy values for all possible subsequences of a nucleic acid sequence.\n\nThe resulting matrix has element [i, j] representing the minimum free energy (ΔG) of the  subsequence from position i to position j. This cache enables efficient energy calculations  for various subsequences without redundant computations.\n\nArguments\n\nseq::AbstractString: The nucleic acid sequence to analyze\ntemp::Real: The temperature (°C) at which to perform the energy calculation (default: 37.0).\n\nReturns\n\nA Matrix{Float64} where element [i, j] contains the free energy (in kcal/mol) of the subsequence  from position i to position j, inclusive. Elements where j < i contain Inf as they represent  invalid ranges, and single-nucleotide subsequences also have Inf as they don't have meaningful energy values.\n\nExamples\n\njulia> SeqFold.dg_cache(\"ATCAT\")\n5×5 Matrix{Float64}:\n -Inf   Inf   Inf   Inf    4.0\n -Inf  -Inf   Inf   Inf   Inf\n -Inf  -Inf  -Inf   Inf   Inf\n -Inf  -Inf  -Inf  -Inf   Inf\n -Inf  -Inf  -Inf  -Inf  -Inf\n\njulia> SeqFold.dg_cache(\"ATCAT\", temp=4)\n5×5 Matrix{Float64}:\n -Inf   Inf   Inf   Inf    3.6\n -Inf  -Inf   Inf   Inf   Inf\n -Inf  -Inf  -Inf   Inf   Inf\n -Inf  -Inf  -Inf  -Inf   Inf\n -Inf  -Inf  -Inf  -Inf  -Inf\n\nImplementation\n\nThe function uses dynamic programming to build a cache of free energy values for all subsequences. The algorithm has O(n²) time and space complexity, where n is the sequence length. This approach avoids redundant calculations when multiple energy values for different subsequences are needed.\n\nnote: Note\nThe reliability of this function is questionable. For given SeqFold.dg_cache(seq) its [1, end]-th element always equals to the dg(seq) called for the same temp value, but other [i, j] values oftentimes fail to represent exact dg(seq[i:j]). The flaw may be with the original algorithm, as was shown.\n\nSee also\n\nfold, SeqFold.tm_cache, SeqFold.gc_cache\n\n\n\n\n\n","category":"function"},{"location":"#SeqFold","page":"Home","title":"SeqFold","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SeqFold.jl is a high-performance Julia reimplementation of seqfold Python library for predicting nucleic acid secondary structures and calculating melting temperatures, which is, in turn, an implementation of the Zuker, 1981 dynamic programming algorithm, the basis for UNAFold/mfold, with energy functions from SantaLucia, 2004 (DNA) and Turner, 2009 (RNA).","category":"page"},{"location":"#Motivation","page":"Home","title":"Motivation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Secondary structure prediction is essential for:\nDesigning PCR primers with minimal secondary structure;\nCreating oligos for genome editing techniques like MAGE;\nTuning ribosome binding site (RBS) expression rates;\nAnalyzing potential off-target binding in CRISPR applications.\nWhile the Python seqfold library provides a minimalist open-source alternative to proprietary UNAFold/mfold, it has several limitations:\nPerformance bottlenecks in the pure Python implementation;\nUndocumented bugs in melting temperature calculations;\nLimited control over buffer conditions for T_m calculations.\nSeqFold.jl addresses these issues, here are the key points:\nFor sequence folding the compatibility with the original seqfold library results is preserved (identical folding algorithm is used);\nFor accurate T_m calculation buffer condition control is provided to user (physically impossible buffer conditions cause errors with meaningful error messages);\nResults of T_m calculation are validated against Biopython's reference implementation;\nSignificantly improved performance through Julia's JIT compilation. For oligs of 20 nt (a typical length for primer sequences) more than 4× speedup for tm and more than 20× speedup for fold is achieved: (Image: seqfold vs SeqFold.jl)","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"First option (inside Julia REPL):","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]\npkg> add SeqFold","category":"page"},{"location":"","page":"Home","title":"Home","text":"Second option (from Julia scripts):","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"SeqFold\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"either way you should now be able to call the package:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using SeqFold","category":"page"},{"location":"#SeqFold.SeqFold","page":"Home","title":"SeqFold.SeqFold","text":"Nucleic acid folding and melting temperature calculation\n\nExports: tm, MeltingConditions, fold, dg, dot_bracket\n\nDocumentation: https://phlaster.github.io/SeqFold.jl/\n\n\n\n\n\n","category":"module"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
