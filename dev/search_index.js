var documenterSearchIndex = {"docs":
[{"location":"#SeqFold","page":"Home","title":"SeqFold","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for SeqFold.","category":"page"},{"location":"#SeqFold.SeqFold","page":"Home","title":"SeqFold.SeqFold","text":"SeqFold.jl, v0.0.1\n\nIntroduction\n\nSeqFold.jl is a high-performance Julia reimplementation of seqfold Python library for predicting nucleic acid secondary structures and calculating melting temperatures, which is, in turn,   is an implementation of the Zuker, 1981 dynamic programming algorithm, the basis for   UNAFold/mfold,   with energy functions from SantaLucia, 2004 (DNA) and Turner, 2009 (RNA).\n\nBasic Usage\n\nMelting Temperature Calculation\n\njulia> seq = \"GGGAGGTCAGCAAACCTGAACCTGTTGAGATGTTGACGTCAGGAAACCCT\";\n\njulia> tm(seq) # melting at PCR conditions, same as tm(seq, conditions=:pcr)\n80.4\n\njulia> MeltingConditions(:pcr) # here they are as a preset inherited from seqfold library\nMeltingConditions (PCR preset)\n  • NEB PCR buffer conditions for Taq DNA Polymerase\n  • seq1 concentration: 250.0 nM (typical primer concentration)\n  • seq2 concentration: 0.0 nM (asymmetric PCR)\n  • Mg²⁺: 1.5 mM (optimal for Taq DNA Polymerase per NEB guidelines)\n  • K⁺: 50.0 mM\n  • Tris: 2.0 mM\n  • dNTPs: 0.2 mM\n\njulia> tm(seq, Mg=5) # altering default conditions\n81.4\n\njulia> MeltingConditions(:std) # second preset, inherited from seqfold library\nMeltingConditions (standard preset)\n  • Standard hybridization buffer\n  • seq1 concentration: 25.0 nM\n  • seq2 concentration: 25.0 nM\n  • Na⁺: 50.0 mM\n\njulia> tm(seq, conditions=:std, Na=150) # altering chosen preset\n79.8\n\njulia> custom_conds = MeltingConditions( # Specifying custom conditions\n       seq1_conc=30,seq2_conc=20,Na=5,K=5,Tris=15,Mg=0,dNTPs=0)\nMeltingConditions (custom)\n  • seq1 concentration: 30.0 nM\n  • seq2 concentration: 20.0 nM\n  • Na⁺: 5.0 mM\n  • K⁺: 5.0 mM\n  • Tris: 15.0 mM\n\njulia> tm(seq, conditions=custom_conds, Tris=50) # flexible adjustments\n68.4\n\nSecondary Structure Prediction\n\n# Get the list of possible secondary structures for a sequence\njulia> folded = fold(seq) # calculated at 37°C by default, Julia uses 1-based indexing\n12-element Vector{SeqFold.Structure}:\n    3   40   -1.3  STACK:GA/CT    \n    4   39   -1.4  STACK:AGG/TGC  \n    6   37   -1.5  STACK:GT/CA    \n    7   36   -1.3  STACK:TC/AG    \n    8   35   -1.5  STACK:CA/GT    \n    9   34   -2.0  STACK:AGC/TTG  \n   11   32   -1.5  STACK:CA/GT    \n   12   31    2.8  INTERIOR_LOOP:4/2\n   16   29   -1.3  STACK:CT/GA    \n   17   28   -0.1  STACK:TGA/AGT  \n   19   26   -1.0  STACK:AA/TT    \n   20   25    3.5  HAIRPIN:AC/TG \n\njulia> dot_bracket(seq, folded) # get the dot-bracket notation\n\"..((.((((.((...((.((....)).)).)).)))).))..........\"\n\njulia> folded_hot = fold(seq, temp=80)\n4-element Vector{SeqFold.Structure}:\n    7   19   -0.4  STACK:TC/AG    \n    8   18   -0.5  STACK:CA/GT    \n    9   17   -0.4  STACK:AG/TC    \n   10   16    3.6  HAIRPIN:GC/CC \n\njulia> dot_bracket(seq, folded_hot) # at a higher temperature number of secondary structures is decreased\n\"......((((.....))))...............................\"\n\njulia> dg(folded) # get the total free energy of the predicted secondary structures\n-6.6\n\njulia> dg(folded_hot)\n2.3\n\njulia> dg(seq, temp=4) # this method calls the computationally intensive `fold` internally\n-16.2\n\nCitations\n\nPapers, which helped in developing the original seqfold package:\n\nNussinov, 1980:\nNussinov, Ruth, and Ann B. Jacobson. \"Fast algorithm for predicting the secondary structure of single-stranded RNA.\" Proceedings of the National Academy of Sciences 77.11 (1980): 6309-6313.\nZuker, 1981:\nZuker, Michael, and Patrick Stiegler. \"Optimal computer folding of large RNA sequences using thermodynamics and auxiliary information.\" Nucleic acids research 9.1 (1981): 133-148.\nJaeger, 1989:\nJaeger, John A., Douglas H. Turner, and Michael Zuker. \"Improved predictions of secondary structures for RNA.\" Proceedings of the National Academy of Sciences 86.20 (1989): 7706-7710.\nSantaLucia, 2004:\nSantaLucia Jr, John, and Donald Hicks. \"The thermodynamics of DNA structural motifs.\" Annu. Rev. Biophys. Biomol. Struct. 33 (2004): 415-440.\nTurner, 2009:\nTurner, Douglas H., and David H. Mathews. \"NNDB: the nearest neighbor parameter database for predicting stability of nucleic acid secondary structure.\" Nucleic acids research 38.suppl_1 (2009): D280-D282.\nWard, 2017:\nWard, M., Datta, A., Wise, M., & Mathews, D. H. (2017). Advanced multi-loop algorithms for RNA secondary structure prediction reveal that the simplest model is best. Nucleic acids research, 45(14), 8541-8550.\n\nExports:\n\ntm, MeltingConditions, fold, dg, dot_bracket\n\n\n\n\n\n","category":"module"},{"location":"#SeqFold.DNA_BULGE_LOOPS","page":"Home","title":"SeqFold.DNA_BULGE_LOOPS","text":"Enthalpy and entropy increments for length depedence of bulge loops\n\nWere calculated from delta G Table 4 of SantaLucia, 2004:\n\nAnnu.Rev.Biophs.Biomol.Struct.33:415-40 doi: 10.1146/annurev.biophys.32.110601.141800 The Thermodynamics of DNA Structural Motifs SantaLucia and Hicks, 2004\n\nFor bulge loops of size 1, the intervening NN energy is used. Closing AT penalty is applied on both sides\n\n\n\n\n\n","category":"constant"},{"location":"#SeqFold.DNA_DE","page":"Home","title":"SeqFold.DNA_DE","text":"DNA dangling ends:\n\nBommarito et al. (2000), Nucl Acids Res 28: 1929-1934\n\n\n\n\n\n","category":"constant"},{"location":"#SeqFold.DNA_HAIRPIN_LOOPS","page":"Home","title":"SeqFold.DNA_HAIRPIN_LOOPS","text":"Enthalpy and entropy increments for length depedence of hairpin loops\n\nWere calculated from delta G Table 4 of SantaLucia, 2004:\n\nAnnu.Rev.Biophs.Biomol.Struct.33:415-40 doi: 10.1146/annurev.biophys.32.110601.141800 The Thermodynamics of DNA Structural Motifs SantaLucia and Hicks, 2004\n\nFor hairpins of length 3 and 4, the entropy values are looked up in the DNATRITETRA_LOOPS Dict\n\nFrom formula 8-9 of the paper: An additional 1.6 delta entropy penalty if the hairpin is closed by AT\n\n\n\n\n\n","category":"constant"},{"location":"#SeqFold.DNA_INTERNAL_LOOPS","page":"Home","title":"SeqFold.DNA_INTERNAL_LOOPS","text":"Enthalpy and entropy increments for length dependence of internal loops\n\nWere calculated from delta G Table 4 of SantaLucia, 2004:\n\nAnnu.Rev.Biophs.Biomol.Struct.33:415-40 doi: 10.1146/annurev.biophys.32.110601.141800 The Thermodynamics of DNA Structural Motifs SantaLucia and Hicks, 2004\n\nAdditional loop sizes are accounted for with the Jacobson-Stockmayer entry extrapolation formula in paper: delta G (loop-n) = delta G (loop-x) + 2.44 x R x 310.15 x ln(n / x)\n\nAdditional correction is applied for asymmetric loops in paper: delta G (asymmetry) = |length A - length B| x 0.3 (kcal / mol) where A and B are lengths of both sides of loop\n\n\n\n\n\n","category":"constant"},{"location":"#SeqFold.DNA_INTERNAL_MM","page":"Home","title":"SeqFold.DNA_INTERNAL_MM","text":"Internal mismatch table (DNA):\n\nAllawi & SantaLucia (1997), Biochemistry 36: 10581-10594\nAllawi & SantaLucia (1998), Biochemistry 37: 9435-9444\nAllawi & SantaLucia (1998), Biochemistry 37: 2170-2179 * \nAllawi & SantaLucia (1998), Nucl Acids Res 26: 2694-2701 *\nPeyret et al. (1999), Biochemistry 38: 3468-3477 *\n\n\n\n\n\n","category":"constant"},{"location":"#SeqFold.DNA_MULTIBRANCH","page":"Home","title":"SeqFold.DNA_MULTIBRANCH","text":"a, b, c, d in a linear multi-branch energy change function.\n\nInferred from: Supplemental Material: Annu.Rev.Biophs.Biomol.Struct.33:415-40 doi: 10.1146/annurev.biophys.32.110601.141800 The Thermodynamics of DNA Structural Motifs SantaLucia and Hicks, 2004\n\n\n\n\n\n","category":"constant"},{"location":"#SeqFold.DNA_NN","page":"Home","title":"SeqFold.DNA_NN","text":"The Thermodynamics of DNA Structural Motifs\n\nSantaLucia and Hicks, 2004\n\n\n\n\n\n","category":"constant"},{"location":"#SeqFold.DNA_TERMINAL_MM","page":"Home","title":"SeqFold.DNA_TERMINAL_MM","text":"Terminal mismatch table (DNA):\n\nSantaLucia & Peyret (2001) Patent Application WO 01/94611\n\n\n\n\n\n","category":"constant"},{"location":"#SeqFold.DNA_TRI_TETRA_LOOPS","page":"Home","title":"SeqFold.DNA_TRI_TETRA_LOOPS","text":"Experimental delta H and delta S for tri/tetra loops:\n\nSupplemental Material: Annu.Rev.Biophs.Biomol.Struct.33:415-40\n\ndoi: 10.1146/annurev.biophys.32.110601.141800 The Thermodynamics of DNA Structural Motifs SantaLucia and Hicks, 2004\n\ndelta S was computed using delta G and delta H and is in cal / (K x mol)\n\n(versus delta H in kcal / mol)\n\n\n\n\n\n","category":"constant"},{"location":"#SeqFold.MeltingConditions","page":"Home","title":"SeqFold.MeltingConditions","text":"MeltingConditions(seq1_conc, seq2_conc, Na, K, Tris, Mg, dNTPs)\n\nRepresents buffer conditions for melting temperature calculation.\n\nFields and Units\n\nseq1_conc, seq2_conc: Sequence concentrations in nM (nanomolar)\nNa, K, Tris, Mg, dNTPs: Buffer component concentrations in mM (millimolar)\n\nExamples\n\njulia> MeltingConditions(:pcr)\nMeltingConditions (PCR preset)\n  • NEB PCR buffer conditions for Taq DNA Polymerase\n  • seq1 concentration: 250.0 nM (typical primer concentration)\n  • seq2 concentration: 0.0 nM (asymmetric PCR)\n  • Mg²⁺: 1.5 mM (optimal for Taq DNA Polymerase per NEB guidelines)\n  • K⁺: 50.0 mM\n  • Tris: 2.0 mM\n  • dNTPs: 0.2 mM\n\njulia> MeltingConditions(:std)\nMeltingConditions (standard preset)\n  • Standard hybridization buffer\n  • seq1 concentration: 25.0 nM\n  • seq2 concentration: 25.0 nM\n  • Na⁺: 50.0 mM\n\njulia> MeltingConditions(seq1_conc=10,seq2_conc=0,Na=0,K=0,Tris=10,Mg=0,dNTPs=0)\nMeltingConditions (custom)\n  • seq1 concentration: 10.0 nM\n  • seq2 concentration: 0.0 nM\n  • Tris: 10.0 mM\n\njulia> MeltingConditions(10,0,0,0,0,5,0)\nMeltingConditions (custom)\n  • seq1 concentration: 10.0 nM\n  • seq2 concentration: 0.0 nM\n  • Mg²⁺: 5.0 mM (higher than NEB's recommended 1.5-2.0 mM range)\n\njulia> MeltingConditions(seq1_conc=0,seq2_conc=0,Na=5,K=0,Tris=0,Mg=0,dNTPs=0)\nERROR: ArgumentError: DNA concentration is too low!\n[...]\n\njulia> MeltingConditions(seq1_conc=10,seq2_conc=10,Na=0,K=0,Tris=0,Mg=0,dNTPs=0)\nERROR: ArgumentError: No cations for salt correction (Mg=0, Na=0, K=0, Tris=0)\n[...]\n\nSee also\n\ntm, SeqFold.tm_cache\n\n\n\n\n\n","category":"type"},{"location":"#SeqFold.Structure","page":"Home","title":"SeqFold.Structure","text":"Structure(e, desc, ij)\n\nRepresents a structural element within a predicted nucleic acid secondary structure.\n\nA Structure object encapsulates the energetic contribution (e), a descriptive string (desc) detailing the type of structural element (e.g., hairpin, stack, bulge, multibranch), and the base-pairing information (ij).\n\nThis type is primarily used internally by the folding algorithm (see fold) to represent and cache the energetics of different structural motifs. It can also be used to inspect the detailed components of a folded structure.\n\nFields\n\ne::Float64: The free energy contribution (in kcal/mol) of this structural element. A value of -Inf typically signifies an uninitialized or invalid structure, while Inf often represents a null or discarded possibility during folding.\ndesc::String: A human-readable description of the structural element. Common descriptions include:\n\"HAIRPIN:<seq>\": A hairpin loop closed by specific base pairs.\n\"STACK:<bp1>/<bp2>\": A stacked base pair.\n\"BULGE:<size>\": A bulge loop of a specific size.\n\"INTERIOR_LOOP:<size1>/<size2>\": An interior loop with specified sizes on each side.\n\"BIFURCATION:<unpaired>n/<helices>h\": A multibranch loop with a certain number of unpaired nucleotides and helices.\nij::Vector{Tuple{Int, Int}}: A list of base-pair indices (i, j) involved in this structural element. For simple elements like a single hairpin or stack, this typically contains one tuple (i, j) indicating the 1-based indices of the paired nucleotides. For complex elements like multibranch loops, it can contain multiple tuples representing the various stems (helices) that constitute the junction.\n\nExamples\n\njulia> s1 = SeqFold.Structure() # Default, uninitialized\n   0    0   -Inf\n\njulia> s2 = SeqFold.Structure(-3.2, \"HAIRPIN:CG/CG\", [(2, 7)])\n   2    7   -3.2  HAIRPIN:CG/CG\n\njulia> s3 = SeqFold.Structure(5.1, \"BIFURCATION:2n/3h\", [(1, 10), (15, 20), (25, 30)])\n   1   10    5.1  BIFURCATION:2n/3h\n\njulia> Bool(s1) # Check if structure is valid (not -Inf)\nfalse\n\njulia> Bool(s2)\ntrue\n\njulia> s2 == SeqFold.Structure(-3.2, \"HAIRPIN:CG/CG\", [(2, 7)]) # Structures can be compared\ntrue\n\nSee also\n\nfold, dg, dot_bracket\n\n\n\n\n\n","category":"type"},{"location":"#SeqFold._bulge-NTuple{7, Any}","page":"Home","title":"SeqFold._bulge","text":"Calculate the free energy associated with a bulge.\n\nArgs:     seq: The full folding DNA/RNA sequence (uppercase).     i: The start index of the bulge.     i1: The index to the right of i.     j: The end index of the bulge.     j1: The index to the left of j.     temp: Temperature in Kelvin.     emap: Map to DNA/RNA energies (Energies struct).\n\nReturns:     Float64: The increment in free energy from the bulge.\n\n\n\n\n\n","category":"method"},{"location":"#SeqFold._cache-Tuple{Any, Any}","page":"Home","title":"SeqFold._cache","text":"Create caches for the wcache and vcache\n\nThe Structs is useful for gathering many possible energies between a series of (i,j) combinations.\n\nArgs:     seq: The sequence to fold\n\nKeyword Args:     temp: The temperature to fold at\n\nReturns:     (w_cache, v_cache) tuple\n\n\n\n\n\n","category":"method"},{"location":"#SeqFold._d_g-Tuple{Any, Any, Any}","page":"Home","title":"SeqFold._d_g","text":"Find the free energy given delta h, s and temp\n\nArgs:     d_h: The enthalpy increment in kcal / mol     d_s: The entropy increment in cal / mol     temp_K: The temperature in Kelvin\n\nReturns:     The free energy increment in kcal / (mol x K)\n\n\n\n\n\n","category":"method"},{"location":"#SeqFold._hairpin-NTuple{5, Any}","page":"Home","title":"SeqFold._hairpin","text":"Calculate the free energy of a hairpin.\n\nArgs:     seq: The sequence we're folding (uppercase).     i: The index of the start of hairpin.     j: The index of the end of hairpin (1-based, inclusive).     temp: Temperature in Kelvin.     emap: Energy map for DNA/RNA (Energies struct).\n\nReturns:     Float64: The free energy increment from the hairpin structure.\n\n\n\n\n\n","category":"method"},{"location":"#SeqFold._internal_loop-NTuple{7, Any}","page":"Home","title":"SeqFold._internal_loop","text":"Calculate the free energy of an internal loop.\n\nThe first and last bp of both left and right sequences are not themselves parts of the loop, but are the terminal bp on either side of it. They are needed for when there's a single internal looping bp (where just the mismatching free energies are used).\n\nNote that both left and right sequences are in 5' to 3' direction.\n\nThis is adapted from the \"Internal Loops\" section of SantaLucia/Hicks, 2004.\n\nArgs:     seq: The sequence we're folding (uppercase).     i: The index of the start of structure on left side.     i1: The index to the right of i.     j: The index of the end of structure on right side.     j1: The index to the left of j.     temp: Temperature in Kelvin.     emap: Dictionary mapping to energies for DNA/RNA (Energies struct).\n\nReturns:     Float64: The free energy associated with the internal loop.\n\n\n\n\n\n","category":"method"},{"location":"#SeqFold._j_s-NTuple{4, Any}","page":"Home","title":"SeqFold._j_s","text":"Estimate the free energy of length query_len based on one of length known_len.\n\nThe Jacobson-Stockmayer entry extrapolation formula is used for bulges, hairpins, etc that fall outside the 30nt upper limit for pre-calculated free-energies. See SantaLucia and Hicks (2004).\n\nArgs:     querylen: Length of element without known free energy value     knownlen: Length of element with known free energy value (dgx)     dgx: The free energy of the element knownlen     tempK: Temperature in Kelvin\n\nReturns:     Free energy for a structure of length query_len\n\n\n\n\n\n","category":"method"},{"location":"#SeqFold._min_struct-Tuple","page":"Home","title":"SeqFold._min_struct","text":"Return the struct with the lowest free energy that isn't -inf (undef)\n\nArgs:     structs: Structures being compared\n\nReturns:     struct: The min free energy structure\n\n\n\n\n\n","category":"method"},{"location":"#SeqFold._multi_branch","page":"Home","title":"SeqFold._multi_branch","text":"Calculate a multi-branch energy penalty using a linear formula.\n\nFrom Jaeger, Turner, and Zuker, 1989. Found to be better than logarithmic in Ward, et al. 2017.\n\nArgs:     seq: The sequence being folded (uppercase).     i: The left starting index.     k: The mid-point in the search.     j: The right ending index.     temp: Folding temp in Kelvin.     vcache: Cache of energies where V(i,j) bond. Stores Structure.     wcache: Cache of min energy of substructures between W(i,j). Stores Structure.     emap: Map to DNA/RNA energies (Energies struct).     helix: Whether this multibranch is enclosed by a helix (V(i,j) forms a base pair).\n\nReturns:     Structure: A multi-branch structure.\n\n\n\n\n\n","category":"function"},{"location":"#SeqFold._pair-NTuple{5, Any}","page":"Home","title":"SeqFold._pair","text":"Return a stack representation, a key for the NN maps\n\nArgs:     s: Sequence being folded     i: leftmost index     i1: index to right of i     j: rightmost index     j1: index to left of j\n\nReturns:     string representation of the pair\n\n\n\n\n\n","category":"method"},{"location":"#SeqFold._stack-NTuple{7, Any}","page":"Home","title":"SeqFold._stack","text":"Get the free energy for a stack. Using the indexes i and j, check whether it's at the end of the sequence or internal. Then check whether it's a match or mismatch, and return. Two edge-cases are terminal mismatches and dangling ends. The energy of a dangling end is added to the energy of a pair where i XOR j is at the sequence's end.\n\nArgs:     seq: The full folding sequence (uppercase).     i: The start index on left side of the pair/stack.     i1: The index to the right of i.     j: The end index on right side of the pair/stack.     j1: The index to the left of j.     temp: Temperature in Kelvin.     emap: Energy map for DNA/RNA (Energies struct).\n\nReturns:     Float64: The free energy of the NN pairing.\n\n\n\n\n\n","category":"method"},{"location":"#SeqFold._traceback-NTuple{4, Any}","page":"Home","title":"SeqFold._traceback","text":"Traceback thru the V(i,j) and W(i,j) caches to find the structure.\n\nFor each step, get to the lowest energy W(i,j) within that block. Store the structure in W(i,j). Inc i and j. If the next structure is viable according to V(i,j), store as well. Repeat.\n\nArgs:     i: The leftmost index to start searching in.     j: The rightmost index to start searching in.     vcache: Cache of energies where i and j bond. Stores Structure.     wcache: Cache of energies/sub-structures between or with i and j. Stores Structure.\n\nReturns:     Vector{Structure}: A list of Structs in the final secondary structure.\n\n\n\n\n\n","category":"method"},{"location":"#SeqFold._trackback_energy-Tuple{Any}","page":"Home","title":"SeqFold._trackback_energy","text":"Add energy to each structure, based on how it's W(i,j) differs from the one after.\n\nArgs:     structs: The structures for whom energy is being calculated.\n\nReturns:     Vector{Structure}: Structures in the folded DNA with energy.\n\n\n\n\n\n","category":"method"},{"location":"#SeqFold._v!-NTuple{7, Any}","page":"Home","title":"SeqFold._v!","text":"Find, store and return the minimum free energy of the structure between i and j. If i and j don't base pair, store and return INF. See: Figure 2B of Zuker, 1981\n\nArgs:     seq: The sequence being folded (uppercase).     i: The start index.     j: The end index (1-based, inclusive).     temp: The temperature in Kelvin.     vcache: Free energy cache for if i and j base pair. Stores Structure.     wcache: Free energy cache for lowest energy structure from i to j. Stores Structure.     emap: Energy map for DNA/RNA (Energies struct).\n\nReturns:     Structure: The minimum free energy structure possible between i and j.\n\n\n\n\n\n","category":"method"},{"location":"#SeqFold._w!-NTuple{7, Any}","page":"Home","title":"SeqFold._w!","text":"Find and return the lowest free energy structure in Sij subsequence (1-based indices). This function calculates and stores results in w_cache to avoid recomputation. Figure 2B in Zuker and Stiegler, 1981.\n\nArgs:     seq: The sequence being folded.     i: The start index.     j: The end index (1-based, inclusive).     temp: The temperature in Kelvin.     vcache: Free energy cache for if i and j base pair. Stores Structure.     wcache: Free energy cache for lowest energy structure from i to j. Stores Structure.     emap: Energy map for DNA/RNA (Energies struct).\n\nReturns:     Structure: The minimum free energy structure for the subsequence from i to j.\n\n\n\n\n\n","category":"method"},{"location":"#SeqFold.dg-Tuple{AbstractString}","page":"Home","title":"SeqFold.dg","text":"dg(seq; temp = 37.0) -> Float64\ndg(structures) -> Float64\n\nCompute the minimum free energy (ΔG, kcal/mol⁻¹) of a single-stranded nucleic acid sequence at a specified temperature.\n\nThe function is a thin wrapper around the more general fold routine, which generates all energetically feasible secondary structures for the sequence.   Only the sum of the free-energy contributions of the returned structures is reported, rounded to two decimal places.\n\nArguments\n\nseq::AbstractString – the nucleotide sequence to be folded;\ntemp::Real – the temperature (°C) at which to perform the folding (default: 37.0);\nstructures::Vector{Structure} – result of fold function.\n\nReturns\n\nΔG::Float64 – the total free energy of the predicted structure, rounded to two decimal places.\n\nExamples\n\njulia> seq = \"GCGCGCGCGCG\";\n\njulia> dg(seq)\n-3.0\n\njulia> dg(seq, temp=20)\n-4.9\n\njulia> structures = fold(seq);\n\njulia> dg(structures)\n-3.0\n\nSee also\n\nfold, SeqFold.dg_cache\n\n\n\n\n\n","category":"method"},{"location":"#SeqFold.dg_cache","page":"Home","title":"SeqFold.dg_cache","text":"Fold a nucleic acid sequence and return the estimated ΔG of each (i,j) pairing.\n\nArgs:     seq: The nucleic acid sequence to fold\n\nKeyword Args:     temp: The temperature to fold at\n\nReturns:     Cache: A Vector{Vector} where each [i][j] pairing corresponds to the         minimum free energy between i and j\n\n\n\n\n\n","category":"function"},{"location":"#SeqFold.dot_bracket-Tuple{AbstractString, Vector{SeqFold.Structure}}","page":"Home","title":"SeqFold.dot_bracket","text":"dot_bracket(seq, structs) -> String\n\nGenerate the dot-bracket notation representation of a predicted nucleic acid secondary structure.\n\nArguments\n\nseq::AbstractString: The original nucleotide sequence that was folded.\nstructs::Vector{Structure}: A vector of Structure objects describing the folded structure, typically obtained from the fold function.\n\nExamples\n\njulia> s = \"AATTACGTTAC\";\n\njulia> dot_bracket(s, fold(s))\n\"((.....))..\"\n\njulia> seq2 = \"GGGAGGTCAGCAAACCTGAACCTGTTGAGATGTTGACGTCAGGAAACCCT\";\n\njulia> structs2 = fold(seq2)\n12-element Vector{SeqFold.Structure}:\n    3   40   -1.3  STACK:GA/CT    \n    4   39   -1.4  STACK:AGG/TGC  \n    6   37   -1.5  STACK:GT/CA    \n    7   36   -1.3  STACK:TC/AG    \n    8   35   -1.5  STACK:CA/GT    \n    9   34   -2.0  STACK:AGC/TTG  \n   11   32   -1.5  STACK:CA/GT    \n   12   31    2.8  INTERIOR_LOOP:4/2\n   16   29   -1.3  STACK:CT/GA    \n   17   28   -0.1  STACK:TGA/AGT  \n   19   26   -1.0  STACK:AA/TT    \n   20   25    3.5  HAIRPIN:AC/TG   \n\njulia> dbn = dot_bracket(seq2, structs2)\n\"..((.((((.((...((.((....)).)).)).)))).))..........\"\n\njulia> length(dbn) == length(seq2)\ntrue\n\njulia> count(==('('), dbn)  # Count base pairs\n12\n\nNotes\n\nThe function only considers the base pairs explicitly listed in the .ij field of each Structure.\nIt does not validate that the input structures are consistent or represent a physically possible configuration.\nPseudoknots (non-nested base pairs) are not handled by this simple representation and will not be correctly shown if present in the input structures.\n\nSee also\n\nfold, SeqFold.Structure\n\n\n\n\n\n","category":"method"},{"location":"#SeqFold.fold-Tuple{AbstractString}","page":"Home","title":"SeqFold.fold","text":"fold(seq; temp = 37.0) -> Vector{Structure}\n\nPredict the minimum free energy secondary structure of a nucleic acid sequence using a dynamic programming algorithm based on the Zuker and Stiegler (1981) approach. https://www.ncbi.nlm.nih.gov/pmc/articles/PMC326673/pdf/nar00394-0137.pdf\n\nImplements the core of the nucleic acid folding algorithm. It calculates the thermodynamically most stable secondary structure for a given single-stranded DNA or RNA sequence. The result is a vector of  Structure objects, each element representing a distinct secondary structure (e.g., hairpin loop, stacked pair, bulge, interior loop, multibranch loop) that contributes to the overall folded structure.\n\nAn optimization is applied where \"isolated\" base pairs (those not adjacent to other base pairs) are penalized with a high energy cost (1600.0 kcal/mol) to speed up computation. A base pair (i,j) is considered isolated if neither the pair (i-1, j+1) nor the pair (i+1, j-1) are complementary according to the sequence's complementarity rules. This optimization is applied regardless of sequence length.\n\nArguments\n\nseq::AbstractString: DNA/RNA sequence\ntemp::Real: The temperature (°C) at which the folding is performed (default: 37.0).\n\nExamples\n\njulia> fold(\"CCAACCGGTTGG\")\n4-element Vector{SeqFold.Structure}:\n    1   12   -1.8  STACK:CC/GG    \n    2   11   -1.5  STACK:CA/GT    \n    3   10   -1.0  STACK:AA/TT    \n    4    9    3.5  HAIRPIN:AC/TG  \n\njulia> fold(\"CCAACCGGTTGG\", temp=70)\n2-element Vector{SeqFold.Structure}:\n    5   12   -1.6  STACK_DE:CC/GG \n    6   11    3.2  HAIRPIN:CG/GT  \n\nSee also\n\ndg, SeqFold.dg_cache, dot_bracket, SeqFold.Structure\n\n\n\n\n\n","category":"method"},{"location":"#SeqFold.gc_cache-Tuple{AbstractString}","page":"Home","title":"SeqFold.gc_cache","text":"gc_cache(seq) -> Matrix{Float64}\n\nCompute a matrix of GC scores for all possible subsequences of a DNA sequence.\n\nThe resulting matrix has element [i, j] representing the GC score of the DNA subsequence from position i to position j. This cache enables efficient GC ratio calculations for various subsequences without redundant computations.\n\nArguments\n\nseq::AbstractString: The DNA sequence to analyze\n\nReturns\n\nA Matrix{Float64} where element [i, j] contains the GC ratio of the subsequence from position i to j, rounded to one decimal place. Elements where j < i contain Inf as they represent invalid ranges.\n\nExamples\n\njulia> SeqFold.gc_cache(\"GGAA\")\n4×4 Matrix{Float64}:\n  1.0   1.0   0.666667  0.5\n Inf    1.0   0.5       0.333333\n Inf   Inf    0.0       0.0\n Inf   Inf   Inf        0.0\n\njulia> SeqFold.gc_cache(\"GAAA\")\n4×4 Matrix{Float64}:\n  1.0   0.5   0.333333  0.25\n Inf    0.0   0.0       0.0\n Inf   Inf    0.0       0.0\n Inf   Inf   Inf        0.0\n\njulia> SeqFold.gc_cache(\"ATA\")\n3×3 Matrix{Float64}:\n  0.0   0.0  0.0\n Inf    0.0  0.0\n Inf   Inf   0.0\n\njulia> SeqFold.gc_cache(\"GGTT\") == SeqFold.gc_cache(\"CCAA\")\ntrue\n\nSee also\n\nSeqFold.tm_cache, tm\n\n\n\n\n\n","category":"method"},{"location":"#SeqFold.tm-Tuple{AbstractString, AbstractString}","page":"Home","title":"SeqFold.tm","text":"tm(seq1, seq2; conditions=:pcr, kwargs...) -> Float64\ntm(seq; conditions=:pcr, kwargs...)  -> Float64\n\nCalculate melting temperature (Tm °C) for DNA duplex formation using nearest-neighbor thermodynamics.\n\nArguments\n\nseq1::AbstractString: DNA sequence;\nseq2::AbstractString: Another DNA sequence, must be the same length as seq1;\nseq::AbstractString: Single DNA sequence to be matched with its exact complement;\nconditions: Buffer conditions specification (see below);\nkwargs...: Additional parameters to override preset conditions in place.\n\nConditions Specification\n\nThe conditions parameter can be:\n\n:pcr (default) or :std: Use preset conditions;\nMeltingConditions object: Custom conditions (for more info see: MeltingConditions);\nNTuple{7, Float64}: (seq1_conc, seq2_conc, Na, K, Tris, Mg, dNTPs);\nNamedTuple with condition fields.\n\nExamples\n\njulia> tm(\"GGGGGG\")\n15.5\n\njulia> tm(\"GGGGGG\", conditions=:pcr)\n15.5\n\njulia> tm(\"GGGGGG\", Mg=10)\n23.0\n\njulia> tm(\"GGGGGG\", conditions=:std)\n2.6\n\njulia> tm(\"GGGGGG\", conditions=:std, Na=100)\n5.1\n\njulia> tm(\"GGGGGG\", conditions=MeltingConditions(150, 150, 20, 0, 0, 10, 0))\n16.8\n\njulia> tm(\"ACCCCC\", \"GGGGGG\")\n6.2\n\nImplementation\n\nThe calculation uses nearest-neighbor thermodynamic parameters from related literature (follow links below to see sources), accounting for initialization terms, nearest-neighbor pairs, and terminal mismatches when present.\n\nSee also\n\nSeqFold.DNA_NN, SeqFold.DNA_INTERNAL_MM, SeqFold.DNA_TERMINAL_MM, MeltingConditions\n\n\n\n\n\n","category":"method"},{"location":"#SeqFold.tm_cache-Tuple{AbstractString, AbstractString}","page":"Home","title":"SeqFold.tm_cache","text":"tm_cache(seq1, seq2; conditions=:pcr, kwargs...) -> Matrix{Float64}\ntm_cache(seq; conditions=:pcr, kwargs...) -> Matrix{Float64}\n\nCompute a matrix of melting temperatures for all possible subsequences of a DNA sequence pair.\n\nArguments\n\nseq1::AbstractString: DNA sequence;\nseq2::AbstractString: Another DNA sequence, must be the same length as seq1;\nseq::AbstractString: Single DNA sequence to be matched with its exact complement;\nconditions: Buffer conditions specification (see tm docstrings);\nkwargs...: Additional parameters to override preset conditions in place.\n\nReturns\n\nA Matrix{Float64} where element (i, j) contains the melting temperature (in °C) of the subsequence from position i to position j, inclusive. Elements where j < i contain Inf as they represent invalid ranges, and single-nucleotide subsequences also have Inf as they don't have meaningful Tm values.\n\nExamples\n\njulia> SeqFold.tm_cache(\"ATCC\")\n4×4 Matrix{Float64}:\n Inf  -212.6   -95.3   -48.6\n Inf    Inf   -161.6   -82.7\n Inf    Inf     Inf   -135.5\n Inf    Inf     Inf     Inf\n\njulia> SeqFold.tm_cache(\"AAGC\", \"TTCG\")\n4×4 Matrix{Float64}:\n Inf  -204.8   -94.6   -40.3\n Inf    Inf   -166.7   -72.9\n Inf    Inf     Inf   -116.7\n Inf    Inf     Inf     Inf\n\njulia> SeqFold.tm_cache(\"AAGC\", \"TTCG\"; conditions=:std)\n4×4 Matrix{Float64}:\n Inf  -213.1  -109.3   -55.6\n Inf    Inf   -177.9   -88.1\n Inf    Inf     Inf   -129.8\n Inf    Inf     Inf     Inf\n\nImplementation\n\nThe function uses dynamic programming to build a cache of Tm values for all subsequences. The algorithm has O(n²) time and space complexity, where n is the sequence length. This approach avoids redundant calculations when multiple Tm values for different subsequences are needed.\n\nSee also\n\ntm, SeqFold.gc_cache, SeqFold.DNA_NN, SeqFold.DNA_INTERNAL_MM\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
